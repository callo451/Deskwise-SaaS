import { ObjectId } from 'mongodb'
import { getDatabase, COLLECTIONS } from '../mongodb'
import type { KBArticle, ArticleVisibility, ArticleStatus } from '../types'

export interface CreateArticleInput {
  title: string
  content: string
  category: string
  tags: string[]
  visibility: ArticleVisibility
  status?: ArticleStatus // Draft/Published/Archived
  autoGenerated?: boolean
  recordingMetadata?: {
    sessionId: string
    stepCount: number
    duration?: number
    url?: string
    recordedAt?: Date
  }
}

export interface UpdateArticleInput {
  title?: string
  content?: string
  category?: string
  tags?: string[]
  visibility?: ArticleVisibility
  status?: ArticleStatus // Allow updating status (draft â†’ published)
  isArchived?: boolean
}

export interface ArticleFilters {
  category?: string
  visibility?: ArticleVisibility
  isArchived?: boolean
  search?: string
  tags?: string[]
}

export class KnowledgeBaseService {
  /**
   * Create a new article
   */
  static async createArticle(
    orgId: string,
    input: CreateArticleInput,
    author: string
  ): Promise<KBArticle> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const article: KBArticle = {
      _id: new ObjectId(),
      orgId,
      title: input.title,
      content: input.content,
      category: input.category,
      tags: input.tags,
      visibility: input.visibility,
      status: input.status || 'published', // Default to published for backward compatibility
      author,
      views: 0,
      helpful: 0,
      notHelpful: 0,
      isArchived: false,
      autoGenerated: input.autoGenerated || false,
      recordingMetadata: input.recordingMetadata, // Include recording metadata if provided
      createdBy: author,
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true,
    }

    await collection.insertOne(article)

    // Update category article count
    await this.updateCategoryCount(orgId, input.category)

    // Update tag usage counts
    for (const tag of input.tags) {
      await this.updateTagCount(orgId, tag)
    }

    return article
  }

  /**
   * Get all articles with optional filters
   */
  static async getArticles(
    orgId: string,
    filters?: ArticleFilters
  ): Promise<KBArticle[]> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const query: any = { orgId, isActive: true }

    if (filters?.category) {
      query.category = filters.category
    }

    if (filters?.visibility) {
      query.visibility = filters.visibility
    }

    if (filters?.isArchived !== undefined) {
      query.isArchived = filters.isArchived
    }

    if (filters?.tags && filters.tags.length > 0) {
      query.tags = { $in: filters.tags }
    }

    if (filters?.search) {
      query.$or = [
        { title: { $regex: filters.search, $options: 'i' } },
        { content: { $regex: filters.search, $options: 'i' } },
        { category: { $regex: filters.search, $options: 'i' } },
        { tags: { $regex: filters.search, $options: 'i' } },
      ]
    }

    const articles = await collection
      .find(query)
      .sort({ createdAt: -1 })
      .toArray()

    return articles
  }

  /**
   * Search articles (full-text search)
   */
  static async searchArticles(
    orgId: string,
    searchQuery: string,
    visibility?: ArticleVisibility
  ): Promise<KBArticle[]> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const query: any = {
      orgId,
      isActive: true,
      isArchived: false,
      $or: [
        { title: { $regex: searchQuery, $options: 'i' } },
        { content: { $regex: searchQuery, $options: 'i' } },
        { tags: { $regex: searchQuery, $options: 'i' } },
      ],
    }

    if (visibility) {
      query.visibility = visibility
    }

    const articles = await collection
      .find(query)
      .sort({ views: -1, createdAt: -1 })
      .limit(20)
      .toArray()

    return articles
  }

  /**
   * Get article by ID
   */
  static async getArticleById(id: string, orgId: string): Promise<KBArticle | null> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const article = await collection.findOne({
      _id: new ObjectId(id),
      orgId,
      isActive: true,
    })

    return article
  }

  /**
   * Update article
   */
  static async updateArticle(
    id: string,
    orgId: string,
    updates: UpdateArticleInput
  ): Promise<KBArticle | null> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const updateData: any = {
      ...updates,
      updatedAt: new Date(),
    }

    const result = await collection.findOneAndUpdate(
      { _id: new ObjectId(id), orgId, isActive: true },
      { $set: updateData },
      { returnDocument: 'after' }
    )

    return result
  }

  /**
   * Delete article (soft delete)
   */
  static async deleteArticle(id: string, orgId: string): Promise<boolean> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const result = await collection.updateOne(
      { _id: new ObjectId(id), orgId },
      {
        $set: {
          isActive: false,
          updatedAt: new Date(),
        },
      }
    )

    return result.modifiedCount > 0
  }

  /**
   * Archive/unarchive article
   */
  static async archiveArticle(
    id: string,
    orgId: string,
    isArchived: boolean
  ): Promise<KBArticle | null> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const result = await collection.findOneAndUpdate(
      { _id: new ObjectId(id), orgId, isActive: true },
      {
        $set: {
          isArchived,
          updatedAt: new Date(),
        },
      },
      { returnDocument: 'after' }
    )

    return result
  }

  /**
   * Increment article view count
   */
  static async incrementViews(id: string, orgId: string): Promise<void> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    await collection.updateOne(
      { _id: new ObjectId(id), orgId },
      { $inc: { views: 1 } }
    )
  }

  /**
   * Mark article as helpful/not helpful
   */
  static async markHelpful(
    id: string,
    orgId: string,
    isHelpful: boolean
  ): Promise<void> {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const field = isHelpful ? 'helpful' : 'notHelpful'

    await collection.updateOne(
      { _id: new ObjectId(id), orgId },
      { $inc: { [field]: 1 } }
    )
  }

  /**
   * Get all categories
   */
  static async getCategories(orgId: string) {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const categories = await collection
      .aggregate([
        { $match: { orgId, isActive: true, isArchived: false } },
        {
          $group: {
            _id: '$category',
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
      ])
      .toArray()

    return categories.map((cat) => ({
      name: cat._id,
      count: cat.count,
    }))
  }

  /**
   * Get all tags with usage counts
   */
  static async getTags(orgId: string) {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const tags = await collection
      .aggregate([
        { $match: { orgId, isActive: true, isArchived: false } },
        { $unwind: '$tags' },
        {
          $group: {
            _id: '$tags',
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
      ])
      .toArray()

    return tags.map((tag) => ({
      name: tag._id,
      count: tag.count,
    }))
  }

  /**
   * Update category article count (helper)
   */
  private static async updateCategoryCount(
    orgId: string,
    category: string
  ): Promise<void> {
    // Category counts are calculated dynamically via aggregation
    // This is a placeholder for future category metadata storage
  }

  /**
   * Update tag usage count (helper)
   */
  private static async updateTagCount(orgId: string, tag: string): Promise<void> {
    // Tag counts are calculated dynamically via aggregation
    // This is a placeholder for future tag metadata storage
  }

  /**
   * Get knowledge base statistics
   */
  static async getKBStats(orgId: string) {
    const db = await getDatabase()
    const collection = db.collection<KBArticle>(COLLECTIONS.KB_ARTICLES)

    const [
      totalArticles,
      publicArticles,
      internalArticles,
      archivedArticles,
    ] = await Promise.all([
      collection.countDocuments({ orgId, isActive: true, isArchived: false }),
      collection.countDocuments({
        orgId,
        isActive: true,
        isArchived: false,
        visibility: 'public',
      }),
      collection.countDocuments({
        orgId,
        isActive: true,
        isArchived: false,
        visibility: 'internal',
      }),
      collection.countDocuments({
        orgId,
        isActive: true,
        isArchived: true,
      }),
    ])

    // Get total views
    const viewsStats = await collection
      .aggregate([
        { $match: { orgId, isActive: true } },
        {
          $group: {
            _id: null,
            totalViews: { $sum: '$views' },
            totalHelpful: { $sum: '$helpful' },
            totalNotHelpful: { $sum: '$notHelpful' },
          },
        },
      ])
      .toArray()

    const categories = await this.getCategories(orgId)
    const tags = await this.getTags(orgId)

    return {
      total: totalArticles,
      public: publicArticles,
      internal: internalArticles,
      archived: archivedArticles,
      totalViews: viewsStats[0]?.totalViews || 0,
      totalHelpful: viewsStats[0]?.totalHelpful || 0,
      totalNotHelpful: viewsStats[0]?.totalNotHelpful || 0,
      categoriesCount: categories.length,
      tagsCount: tags.length,
    }
  }
}
